# -*- coding: utf-8 -*-
"""ploidy_RF_ensemble_2020_2019

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ByBThg2keN23NVrt-2abaAYkwi3OB6Vh

Train on 2019, deploy on 2020
"""

# connect to google drive
from google.colab import drive
drive.mount('/content/drive')

# import earth engine library
import ee

# establish connection to own earth engine account
ee.Authenticate()
ee.Initialize()

# Commented out IPython magic to ensure Python compatibility.
# call 2019 imagery, 2020 imagery, 2020 aspen mask, RF model
# %cd /content/drive/My\ Drive/Colab\ Notebooks/Aspen/Cytotype

from S2SRstack2020 import stacked2020_JunOct, Colorado
from dist_rf_rmbl_2019 import stackVegRMBL2019
from dist_rf_rmbl_2020 import aspenMask2020
from RFensemble_ploidy import deploy, RFmodelPloidy

# clip imagery to aspen mask
stackVegRMBLaspen2020 = stacked2020_JunOct.mask(aspenMask2020.select('classification'))

# prepare reference data

# import aspen points with ploidy field attached
aspen = ee.FeatureCollection('users/erin_carroll/aspenAssets/refAspenPloidy')
dip = aspen.filter(ee.Filter.eq('ploidy', 2))
trip = aspen.filter(ee.Filter.eq('ploidy', 3))

# subset validation and training samples (25%, 75%)
random2 = dip.randomColumn('x')
validation2 = random2.filter(ee.Filter.lt('x', 0.25))
training2 = random2.filter(ee.Filter.gte('x', 0.25))

random3 = trip.randomColumn('x')
validation3 = random3.filter(ee.Filter.lt('x', 0.25))
training3 = random3.filter(ee.Filter.gte('x', 0.25))

validation = validation2.merge(validation3)
training = training2.merge(training3)

# train on 2019, deploy on 2020
result = RFmodelPloidy(training2, training3, stackVegRMBL2019, stackVegRMBLaspen2020)
print('success')

# accuracy assessment
trainResult = result.sampleRegions(collection=training, properties=['ploidy'], scale=10)
valResult = result.sampleRegions(collection=validation, properties=['ploidy'], scale=10)

# set up export (printing not working - 'too many concurrent aggregations')
expT = ee.batch.Export.table.toDrive(collection=trainResult,
                                     description='trainResult_2020-2019',
                                     fileFormat='CSV')
expV = ee.batch.Export.table.toDrive(collection=valResult,
                                     description='valResult_2020-2019',
                                     fileFormat='CSV')

expT.start()
expV.start()

# when both 'state': 'COMPLETED', move on to next cell to re-import
print(expT.status())
print(expV.status())

# import results from drive

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# authenticate and create the PyDrive client.
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

linkT = 'https://drive.google.com/file/d/1aCj1_phtXr0y83v0cAoc_TbQ_sD_6jsM/view?usp=sharing'
linkV = 'https://drive.google.com/file/d/1hpVw4Opsr9oucLcd3vdcm4zgP4KVx8cU/view?usp=sharing'

import pandas as pd 
  
# to get the id part of the file 
idT = linkT.split("/")[-2] 
idV = linkV.split("/")[-2] 

downloadedT = drive.CreateFile({'id':idT})  
downloadedT.GetContentFile('trainResult_2020-2019.csv')   
trainDF = pd.read_csv('trainResult_2020-2019.csv') 

downloadedV = drive.CreateFile({'id':idV})  
downloadedV.GetContentFile('valResult_2020-2019.csv')   
valDF = pd.read_csv('valResult_2020-2019.csv') 

trainDF['result'] = trainDF['result'].astype(int)
valDF['result'] = trainDF['result'].astype(int)

from sklearn import metrics
print('TRAINING DATASET')
print(metrics.confusion_matrix(trainDF['ploidy'], trainDF['result'], labels=[2,3]))
print(metrics.classification_report(trainDF['ploidy'], trainDF['result'], labels=[2,3]), '\n')
print('VALIDATION DATASET')
print(metrics.confusion_matrix(valDF['ploidy'], valDF['result'], labels=[2,3]))
print(metrics.classification_report(valDF['ploidy'], valDF['result'], labels=[2,3]))

import folium
from folium import plugins

# prepare mapping capabilities (add basemaps and define mapping function)

# Add basemaps to folium
basemaps = {
    'Google Maps': folium.TileLayer(
        tiles = 'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
        attr = 'Google',
        name = 'Google Maps',
        overlay = True,
        control = True
    ),
    'Google Satellite': folium.TileLayer(
        tiles = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
        attr = 'Google',
        name = 'Google Satellite',
        overlay = True,
        control = True
    ),
    'Google Terrain': folium.TileLayer(
        tiles = 'https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',
        attr = 'Google',
        name = 'Google Terrain',
        overlay = True,
        control = True
    )
}

# Define a method for displaying Earth Engine image tiles on a folium map.
def add_ee_layer(self, ee_object, vis_params, name):
    
    try:    
        # display ee.Image()
        if isinstance(ee_object, ee.image.Image):    
            map_id_dict = ee.Image(ee_object).getMapId(vis_params)
            folium.raster_layers.TileLayer(
            tiles = map_id_dict['tile_fetcher'].url_format,
            attr = 'Google Earth Engine',
            name = name,
            overlay = True,
            control = True
            ).add_to(self)
        # display ee.ImageCollection()
        elif isinstance(ee_object, ee.imagecollection.ImageCollection):    
            ee_object_new = ee_object.mosaic()
            map_id_dict = ee.Image(ee_object_new).getMapId(vis_params)
            folium.raster_layers.TileLayer(
            tiles = map_id_dict['tile_fetcher'].url_format,
            attr = 'Google Earth Engine',
            name = name,
            overlay = True,
            control = True
            ).add_to(self)
        # display ee.Geometry()
        elif isinstance(ee_object, ee.geometry.Geometry):    
            folium.GeoJson(
            data = ee_object.getInfo(),
            name = name,
            overlay = True,
            control = True
        ).add_to(self)
        # display ee.FeatureCollection()
        elif isinstance(ee_object, ee.featurecollection.FeatureCollection):  
            ee_object_new = ee.Image().paint(ee_object, 0, 2)
            map_id_dict = ee.Image(ee_object_new).getMapId(vis_params)
            folium.raster_layers.TileLayer(
            tiles = map_id_dict['tile_fetcher'].url_format,
            attr = 'Google Earth Engine',
            name = name,
            overlay = True,
            control = True
        ).add_to(self)
    
    except:
        print("Could not display {}".format(name))
    
# Add EE drawing method to folium.
folium.Map.add_ee_layer = add_ee_layer

# prepare map

# create a folium map object, centered at RMBL
m = folium.Map(location=[38.9587,-106.9878], zoom_start=11)

# add a layer control panel to the map
m.add_child(folium.LayerControl())

# set visualization parameters
rgbVis = {'min': 0.0, 'max': 5000, 'bands': ['B4', 'B3', 'B2']}
vis = {'min':2, 'max':3, 'palette':'red, green'}

# add fullscreen button
plugins.Fullscreen().add_to(m)

m.add_ee_layer(result, {'bands':'confidence', 'min':0, 'max':1, 'palette':'red, yellow, green'}, 'Confidence')
m.add_ee_layer(result, {'bands':'result', 'min':2, 'max':3, 'palette':'#41A7FA, #FA605A'}, 'Ploidy Classification')
m.add_ee_layer(dip, {'color': 'blue'}, 'Diploid')
m.add_ee_layer(trip, {'color': 'red'}, 'Triploid')

# display the map
display(m)